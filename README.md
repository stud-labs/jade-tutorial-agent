#Введение

Это markdown-версия учебника [На IdeaHeap.com](http://www.ideaheap.com/2015/05/jade-setup-for-beginners/).

##Предварительные условия

Данное руководство написано в предположении, что уже есть базовое понимание Java, и что вы способны загрузить [Maven](https://maven.apache.org/) и запустить его в командной строке. Также можно выбрать IDE (Eclipse или Intellij - хорошие варианты).

Более подробную информацию о том, что представляет собой JADE, ищите на [их основном сайте](http://jade.tilab.com/). Jade - фреймворк для обмена сообщениями и набор классов, позволяющих быстро создавать агент-ориентированные приложения.

##Что такое агентное программирование?

Агентное программирование - это парадигма, в которой компоненты состояния и кода работают вместе, создавая независимый модуль, "наблюдающий" за окружающим миром и "выдающий" в этот мир свои действия. Примером простого агента выступает служба, обрабатывающая события, она прослушивает порт и, получив входные данные, реагирует на них.

Модель естественна для человека, знакомого с объектно-ориентированным программированием. JADE отлично справляется с реализацией этой парадигмы, и если вы напишете хорошо спроектированное JADE-приложение, ваш код будет достаточно производительным, поскольку агенты JADE неблокируемы и используют только один поток на одного агента.

#Настройка среды

##Конфигурация Maven

Maven - это система сборки, которая берет на себя добавление зависимостей (вспомогательных библиотек) и позволяет декларативно описать процесс сборки приложения. Она не проста в освоении, но в рамках данного руководства  можно просто использовать приведенный ниже код с указанными командами, остальные зависимости добавляются только по мере их появления.

Ваш проект можно начать с редактирования **pom.xml** в этом примере. В него включены также фреймворк протоколирования (создание журнала помимо JADE), а также инструменты, необходимые для подключения в среде JADE.  Варианты сборки задают два различных способа запуска JADE. Для этого созданы два конфигурационных файла, которые будут описаны в следующем разделе.

##Запуск сборки проектов Maven

После того как все настроено, приложение запускается при помощи следующих двух команд (в разных терминалах, но в одной папке):

    mvn -Pjade-main exec:java
    mvn -Pjade-agent exec:java

У меня получилось собрать запустить, дополнив команды дополнительными ключами.

    mvn exec:java -Pjade-main  -Dmaven.wagon.http.ssl.insecure=true \
        -Dmaven.wagon.http.ssl.allowall=true \
        -Dmaven.wagon.http.ssl.ignore.validity.dates=true
    mvn exec:java -Pjade-agent  -Dmaven.wagon.http.ssl.insecure=true \
        -Dmaven.wagon.http.ssl.allowall=true \
        -Dmaven.wagon.http.ssl.ignore.validity.dates=true

Первая команда запускает JADE с конфигурацией, создающей основной контейнер по умолчанию без пользовательских вами разработанных агентов. Вторая команда запускает JADE-контейнер без пользовательского интерфейса, но загружающий пользовательские (вами разработанные) агенты, указанные в этом конфигурационном файле.

#Конфигурация контейнера

Далее приведены два конфигурационных файла, указанных в настройке плагина ```exec```, файлы определяют, как запускать контейнер JADE.

##Конфигурация главного контейнера JADE

Для работы JADE требуется, чтобы основной контейнер был запущен, но он также поддерживает создание дополнительных контейнеров для запуска агентов. В контейнере может работать множество агентов, а сами контейнеры могут находиться на разных компьютерах, что позволяет реализовать распределенную архитектуру. В коммуникационной среде (платформе) допустим только один основной контейнер JADE, но можно запустить резервный контейнер, выполняющий свои функции в случае выхода из строя основного контейнера.

Первый конфигурационный файл находится в *src/main/resource/jade-main-container.properties*. Он содержит следующее:

    gui=true
    host=localhost
    port=10099
    local-port=10099
    jade_domain_df_autocleanup=true

В результате создается основной контейнер, в котором будет доступен стандартный интерфейс пользователя для отладки и управления средой JADE. Он настраивается на порту 10099.

Строка autocleanup - это настройка для агента JADE 'df', который отвечает за то, чтобы знать, где находятся различные агенты, способные передавать сообщения. По умолчанию JADE не очищает списки уже убитых агентов, но в данной конфигурации такая очиска включена.

##Конфигурация контейнера агента JADE

Контейнер агента спроектирован таким образом, чтобы быть ненавязчивым и легко уничтожаемым. Он запускается без интерфейса пользователя и подключается к основному контейнеру. Ниже приведена конфигурация контейнера для нашего агента.

    agents=\
        sample-agent-1:com.ideaheap.tutorial.jade.agents.sample.SampleAgent(sample-agent-2);\
        sample-agent-2:com.ideaheap.tutorial.jade.agents.sample.SampleAgent(sample-agent-1)
    port=10099
    host=localhost
    main=false
    no-display=true

Поскольку в Maven-е есть некоторые проблемы с очисткой неостановленных проектов, и, если вы хотите создать отдельный проект только для запуска jade-main, то это вполне терпимо. Запуск этого проекта как отдельного исполняемого файла позволит вам сохранить активным его интерфейс пользователя, пока вы создаете и завершаете другие jvm (виртуальные машины Java), запущенные с помощью профиля *jade-agent*.

#Создание примера вашего агента

Данный учебник не просто представляет пример агента, но и включает ряд рекомендаций по архитектуре исходного кода программы агента. Агентное проектирование естественным образом приводит к модульному коду, при этом четко определяется, как модули должны взаимодействовать - при помощи передачи сообщений между агентами. Мы для вас создали следующую структуру каталогов:

<pre>
base.package.name.agents.agentName.AgentNameAgent
                                  .behaviors.Behavior
</pre>

Каждый агент следует этой настройке пакета. Рассмотрим каждый из них подробнее.

##Класс, представляющий агента

В приведенной выше структуре каталогов этот класс будет **base.package.name.agents.agentName.AgentNameAgent**.  Любители очень длинных имен идентификаторов не смущаются таких своих привычек: память в наше время стоит дешево. Такая схема пакетов создает естественную инкапсуляцию для всех вспомогательных классов, появляющихся по мере проектирования агента.

AgentNameAgent отвечает за задание конфигурации агента, а код, реализованный внутри агента, следует шаблону проектирования "инверсии управления" или "инъекции зависимостей" без использования дополнительного фреймворка, например, Spring.

В данном примере созданный агент назван "SampleAgent". Ниже приведен его программный код:

    public class SampleAgent extends Agent {
        private static final Logger logger = LoggerFactory.getLogger(SampleAgent.class);

        @Override
        public void setup() {
            final String otherAgentName = (String) this.getArguments()[0];
            addBehaviour(new IncrementBaseNumber(this, otherAgentName));
        }

        @Override
        public void takeDown() {
        }
    }

Приведен только  самый необходимый код, формирующий класс агента, за исключением кода реестра (который будет рассмотрен в следующем этапе). Данный агент отвечает за обеспечение совместного функционирования классов, формирующих его поведение.

##Класс описания поведения

Класс поведения инкапсулирует все действия. Тут надо сделать несколько очень важных замечаний: самое главное из них - все, что делается в этом классе, должно быть неблокируемым (т.е. не надо делать долго обрабатываемых обращений к базам данных или внешним сервисам в главном потоке). У каждого агента есть один поток, который мультиплексирует КАЖДОЕ поведение.

Подобное требование практически гарантирует, что модель поведения агента будет 'машиной состояний', поскольку сложные взаимодействия естественным образом приведут к такой модели. Данный пример реализации поведения включает в себя три звена: отправка, получение и ответ на сообщение.

###Разбор по отдельным методам

#####action()
Вот небольшая машина состояний, определенная следующим образом:

    @Override
    public void action() {
        switch (state) {
            case START_INCREMENTING:
                startIncrementing();
                break;
            case CONTINUE_INCREMENTING:
                continueIncrementing();
                break;
            case STOP_INCREMENTING:
                stopIncrementing();
                break;
            default:
                block();
        }
    }

Данный метод, являющийся обязательной частью любого класса, реализующего интерфейс Behaviour, вызывается средой JADE непрерывно в цикле. Возникает вопрос, что делает метод *block()* в этом коде после того, как уже было подчеркнуто, насколько важно, чтобы действия были неблокируемыми. В данном случае метод ```block()``` фактически является сигналом для агента-контейнера, что он не должен вызывать это действие снова до тех пор, пока у него не появится причина считать, что ситуация изменилась. Чаще всего это получение сообщения.  Таким образом, *block()* фактически является неблокирующим! Это также означает, что любой код, помещенный после блока(), все равно будет выполнен немедленно.

#####startIncrementing()

Наше поведение начинается с состояния, которое создает и отправляет некоторое сообщение назначенному агенту-получателю. Задача сообщения - послать число 1 агенту-получателю прием это часть конструктора. Конструктор ```build()``` также будет рассмотрен далее.

    private void startIncrementing() {
        agent.send(inform().toLocal(otherAgentName).withContent(1).build());
        state = State.CONTINUE_INCREMENTING;
    }

#####continueIncrementing()

Состояние *continueIncrementing* использует 'обертку', которая проверяет наличие нового сообщения, и если оно уже есть преобразует его содержимое в целое число и вызывает определенный обработчик (обратный вызов, callback):

    private void continueIncrementing() {
        listen(agent, this).forInteger((toIncrement) -> {
            logger.info("Recieved " + toIncrement);
            toIncrement++;
            agent.send(inform().toLocal(otherAgentName).withContent(toIncrement).build());
            if (toIncrement > MAX_INCREMENT) {
                state = State.STOP_INCREMENTING;
            }
        });
    }

Обработчик реализует отправку полученного целого числа из принятого сообщения агенту, заданному в его конструкторе.

#####stopIncrementing()

Класс *stopIncrementing* демонстрирует завершенность действия, чтобы удостовериться, что эксперимент с посылкой сообщений успешен. Можно просто уничтожить отработавшего агента, а можно запрограммировать метод поведения ```done()``` так, чтобы он возвращал "true", а можно поступить так, как в данном примере: уничтожить весь контейнер.

    private void stopIncrementing() {
        listen(agent, this).forInteger((toIgnore) -> {
            logger.info("I'm just going to ignore this: " + toIgnore);
            ContainerKiller.killContainerOf(agent);
        });
    }

#Заключение

С помощью этого простого примера создана группа простых агентов, взаимодействующих друг с другом внутри проекта под управлением Maven-а. Функции **listen** и **inform**, приведенные ранее, являются частью небольшого набора классов  проекта, стимулирующие программиста к более свободному использованию JADE. И это только начало...

**Весь код доступен свободно на [GitHub](https://github.com/IdeaHeap/jade-tutorial-agent)** (оригинал проекта),

Данная адаптация, также свободная, - **[Github](https://github.com/stud-labs/jade-tutorial-agent)**.

**Задача:** в этом примере только два агента взаимодействуют друг с другом для увеличения счетчика. Попробуйте сделать кольцо из трех агентов. Что произойдет, если будет агентский "любовный треугольник", и два агента будут настроены на отправку сообщений одному и тому же агенту?
